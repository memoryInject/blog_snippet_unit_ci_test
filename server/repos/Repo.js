const pool = require('../config/pool');
const toCamelCase = require('./utils/toCamelCase');
const format = require('pg-format');

class Repo {
  table = '';
  columns = [];
  constructor({ table, columns }) {
    this.columns = columns.map((c) => `${table}.${c}`);
    this.table = table;
  }

  config = {
    filter: {
      columns: [],
      type: 'normal',
    },
    condition: {
      column: '',
      value: '',
      cmp: 'eq ne gt lt',
    },
    limiter: {
      limit: -1,
      offset: 0,
    },
    join: {
      foreignKey: '',
      tableName: '',
      columns: [],
    },
  };

  // Find rows in the PostgreSQL
  async find(
    config = {
      filter: { columns: [], type: 'normal' },
      condition: { column: '', value: '', cmp: 'eq ne gt lt' },
      limiter: { limit: -1, offset: 0 },
      join: {
        tableName: '',
        foreignKey: '',
        columns: [],
      },
      returnSql: false,
    }
  ) {
    // Incoming filter: columns: table cloums name in an array, type:- if passed as 'invert' fields will be subtracted from the query eg: { columns: [password], type: 'invert' } this object will return all the colums from the table except password

    // Incoming condition must be like: { column: 'user_id', value: '5', cmp: 'eq' }
    //cmp: gt, lt, eq, ne (gt: greater than, lt: less than, eq: equal, ne: not equal)

    // returnSql = false by default, if in anycase to get the sql
    // generated by this function pass returnSql = true
    // this function will return the sql otherwise this function
    // returns a response from postgres

    // Full example with a table of blogs(id, title, content, user_id) and it has a foreign key of user_id for another table users(id, username, email, password):
    // const foo = BlogRepo.find(filter, condition, limiter, join)
    /**
     * const foo = BlogRepo.find(
     *  { colums: ['content'], type: 'invert' },
     *  { column: 'id', value: '4', cmp: 'lt' },
     *  { limit: 2, offset: 0 },
     *  { tableName: 'users', foreignKey: 'user_id', colums: ['username'] }
     * )
     */

    // SQL output: SELECT blogs.id,blogs.title,blogs.user_id,users.username FROM blogs JOIN users ON users.id = blogs.user_id  WHERE blogs.id < '4' LIMIT '2' OFFSET '0';

    // This internal method will convert cmp to actual operator like =, >, < etc.

    // Destructure config object
    let { filter, condition, limiter, join, returnSql } = config;

    const getOperator = (op) => {
      switch (op) {
        case 'gt':
          return '>';
        case 'lt':
          return '<';
        case 'eq':
          return '=';
        case 'ne':
          return '!=';
        default:
          break;
      }
    };

    // Check if there any condition
    if (condition) {
      if (condition.column && condition.column.length === 0) {
        condition = null;
      }
    }

    // Destructure more if not undefined
    let { columns: filterCols, type } = filter ? filter : (filter = {});
    let { limit, offset } = limiter ? limiter : (limiter = {});
    let {
      tableName,
      foreignKey,
      columns: joinCols,
    } = join ? join : (join = {});

    // Final values and variables for sql command
    let sql;
    let conditionValue = '';
    let limitValue = '';
    let joinValue = '';
    let joinColumns = [];
    let filterColumns = ['*'];

    const globalColumns = this.columns;
    const globalTable = this.table;

    // Add table name to incoming filterCols
    if (filterCols) {
      filterCols = filterCols.map((c) => `${globalTable}.${c}`);
    }

    // If condtion exists then create final condtion SQL statement(WHERE ...)
    if (condition) {
      // Check if the condtion column is exists in the table then create the WHERE (colum name) (=) (value)
      globalColumns.filter((col) => {
        if (condition.column === col.slice(globalTable.length + 1)) {
          conditionValue += format(
            ' WHERE %s %s %L',
            col,
            getOperator(condition.cmp),
            condition.value
          );
        }
      });
    }

    // Check if limiter argument passed then set the LIMIT and OFFSET values
    if (limit >= 0 && offset >= 0) {
      limitValue = format(' LIMIT %L OFFSET %L', limit, offset);
    }

    // Check if join argument passed then create SQL JOIN statement
    if (
      tableName &&
      tableName.length > 0 &&
      foreignKey &&
      foreignKey.length > 0
    ) {
      if (joinCols && joinCols.length > 0) {
        joinColumns = joinCols.map((c) => `${tableName}.${c}`); // eg: ['users.username']
        joinValue = format(
          ' JOIN %I ON %s = %s ',
          tableName,
          `${tableName}.id`,
          `${globalTable}.${foreignKey}`
        );
      }
    }

    // Check if there is any fields passed in the argument then create filtered fields
    if (filterCols && filterCols.length !== 0) {
      if (type === 'invert') {
        filterColumns = globalColumns.filter((col) => {
          if (!filterCols.find((c) => c === col)) {
            return col;
          }
        });
      } else {
        filterColumns = globalColumns.filter((col) => {
          if (filterCols.find((c) => c === col)) {
            return col;
          }
        });
      }
    }

    // Final filterd columns for sql query
    filterColumns = filterColumns.concat(joinColumns);

    // Final sql statement
    sql = format(
      'SELECT %s FROM %I%s%s%s;',
      filterColumns,
      this.table,
      joinValue,
      conditionValue,
      limitValue
    );

    // console.log(sql);

    if (returnSql) {
      return sql;
    }

    const { rows } = await pool.query(sql);

    if (rows.length > 1) {
      return toCamelCase(rows);
    } else {
      return toCamelCase(rows)[0];
    }
  }

  // Find row by id this use the main find function
  async findById(id, filter = { columns: [], type: 'normal' }) {
    const config = {
      filter,
      condition: {
        column: 'id',
        value: id,
        cmp: 'eq',
      },
    };

    return this.find(config);
  }

  // Insert row into the table
  async insert(data = {}) {
    let values = [];
    let columns = [];
    let sql;
    const globalColumns = this.columns;
    const globalTable = this.table;

    for (let key in data) {
      globalColumns.filter((col) => {
        if (key === col.slice(globalTable.length + 1)) {
          columns.push(key);
          values.push(data[key]);
        }
      });
    }

    sql = format(
      'INSERT INTO %I (%s) VALUES (%L) RETURNING *;',
      this.table,
      columns,
      values
    );

    // console.log(sql);

    const { rows } = await pool.query(sql);

    return toCamelCase(rows)[0];
  }

  // Update a row in the table based on id
  async update(id, data = {}) {
    let values = [];
    let sql;
    const globalColumns = this.columns;
    const globalTable = this.table;

    for (let key in data) {
      globalColumns.filter((col) => {
        if (key === col.slice(globalTable.length + 1)) {
          values.push(`${key} = '${data[key]}'`);
        }
      });
    }

    sql = format(
      'UPDATE %I SET %s WHERE id = %L RETURNING *;',
      this.table,
      values,
      id
    );

    const { rows } = await pool.query(sql);

    return toCamelCase(rows)[0];
  }

  // Delete a row in the table based on id
  async delete(id) {
    let sql;
    sql = format('DELETE FROM %I WHERE id = %L RETURNING *;', this.table, id);

    const { rows } = await pool.query(sql);

    return toCamelCase(rows)[0];
  }

  async countRows() {
    let sql;
    sql = format('SELECT COUNT(*) FROM %I;', this.table);

    const { rows } = await pool.query(sql);
    return rows[0];
  }

  getColumns() {
    return this.columns;
  }
}

module.exports = Repo;
